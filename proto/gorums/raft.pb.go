// Code generated by protoc-gen-gogo.
// source: proto/gorums/raft.proto
// DO NOT EDIT!

/*
	Package gorums is a generated protocol buffer package.

	It is generated from these files:
		proto/gorums/raft.proto

	It has these top-level messages:
		Entry
		RequestVoteRequest
		RequestVoteResponse
		AppendEntriesRequest
		AppendEntriesResponse
		RegisterClientRequest
		RegisterClientResponse
		ClientRequestRequest
		ClientRequestResponse
*/
package gorums

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/relab/gorums"

import strconv "strconv"

import bytes "bytes"

import (
	"encoding/binary"
	"hash/fnv"
	"log"
	"net"
	"sort"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
)

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	OK              Status = 0
	NOT_LEADER      Status = -1
	SESSION_EXPIRED Status = -2
)

var Status_name = map[int32]string{
	0:  "OK",
	-1: "NOT_LEADER",
	-2: "SESSION_EXPIRED",
}
var Status_value = map[string]int32{
	"OK":              0,
	"NOT_LEADER":      -1,
	"SESSION_EXPIRED": -2,
}

func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaft, []int{0} }

type Entry struct {
	Term uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{0} }

type RequestVoteRequest struct {
	CandidateID  uint32 `protobuf:"varint,1,opt,name=candidateID,proto3" json:"candidateID,omitempty"`
	Term         uint64 `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	LastLogIndex uint64 `protobuf:"varint,3,opt,name=lastLogIndex,proto3" json:"lastLogIndex,omitempty"`
	LastLogTerm  uint64 `protobuf:"varint,4,opt,name=lastLogTerm,proto3" json:"lastLogTerm,omitempty"`
}

func (m *RequestVoteRequest) Reset()                    { *m = RequestVoteRequest{} }
func (*RequestVoteRequest) ProtoMessage()               {}
func (*RequestVoteRequest) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{1} }

type RequestVoteResponse struct {
	Term        uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	RequestTerm uint64 `protobuf:"varint,2,opt,name=requestTerm,proto3" json:"requestTerm,omitempty"`
	VoteGranted bool   `protobuf:"varint,3,opt,name=voteGranted,proto3" json:"voteGranted,omitempty"`
}

func (m *RequestVoteResponse) Reset()                    { *m = RequestVoteResponse{} }
func (*RequestVoteResponse) ProtoMessage()               {}
func (*RequestVoteResponse) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{2} }

type AppendEntriesRequest struct {
	LeaderID     uint32   `protobuf:"varint,1,opt,name=leaderID,proto3" json:"leaderID,omitempty"`
	Term         uint64   `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	PrevLogIndex uint64   `protobuf:"varint,3,opt,name=prevLogIndex,proto3" json:"prevLogIndex,omitempty"`
	PrevLogTerm  uint64   `protobuf:"varint,4,opt,name=prevLogTerm,proto3" json:"prevLogTerm,omitempty"`
	CommitIndex  uint64   `protobuf:"varint,5,opt,name=commitIndex,proto3" json:"commitIndex,omitempty"`
	Entries      []*Entry `protobuf:"bytes,6,rep,name=entries" json:"entries,omitempty"`
}

func (m *AppendEntriesRequest) Reset()                    { *m = AppendEntriesRequest{} }
func (*AppendEntriesRequest) ProtoMessage()               {}
func (*AppendEntriesRequest) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{3} }

func (m *AppendEntriesRequest) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type AppendEntriesResponse struct {
	FollowerID uint32 `protobuf:"varint,1,opt,name=followerID,proto3" json:"followerID,omitempty"`
	Term       uint64 `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	MatchIndex uint64 `protobuf:"varint,3,opt,name=matchIndex,proto3" json:"matchIndex,omitempty"`
	Success    bool   `protobuf:"varint,4,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *AppendEntriesResponse) Reset()                    { *m = AppendEntriesResponse{} }
func (*AppendEntriesResponse) ProtoMessage()               {}
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{4} }

type RegisterClientRequest struct {
}

func (m *RegisterClientRequest) Reset()                    { *m = RegisterClientRequest{} }
func (*RegisterClientRequest) ProtoMessage()               {}
func (*RegisterClientRequest) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{5} }

type RegisterClientResponse struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=gorums.Status" json:"status,omitempty"`
	ClientID   uint32 `protobuf:"varint,2,opt,name=clientID,proto3" json:"clientID,omitempty"`
	LeaderHint uint32 `protobuf:"varint,3,opt,name=leaderHint,proto3" json:"leaderHint,omitempty"`
}

func (m *RegisterClientResponse) Reset()                    { *m = RegisterClientResponse{} }
func (*RegisterClientResponse) ProtoMessage()               {}
func (*RegisterClientResponse) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{6} }

type ClientRequestRequest struct {
	ClientID       uint32 `protobuf:"varint,1,opt,name=clientID,proto3" json:"clientID,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequenceNumber,proto3" json:"sequenceNumber,omitempty"`
	Command        []byte `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
}

func (m *ClientRequestRequest) Reset()                    { *m = ClientRequestRequest{} }
func (*ClientRequestRequest) ProtoMessage()               {}
func (*ClientRequestRequest) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{7} }

type ClientRequestResponse struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=gorums.Status" json:"status,omitempty"`
	Response   []byte `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	LeaderHint uint32 `protobuf:"varint,3,opt,name=leaderHint,proto3" json:"leaderHint,omitempty"`
}

func (m *ClientRequestResponse) Reset()                    { *m = ClientRequestResponse{} }
func (*ClientRequestResponse) ProtoMessage()               {}
func (*ClientRequestResponse) Descriptor() ([]byte, []int) { return fileDescriptorRaft, []int{8} }

func init() {
	proto.RegisterType((*Entry)(nil), "gorums.Entry")
	proto.RegisterType((*RequestVoteRequest)(nil), "gorums.RequestVoteRequest")
	proto.RegisterType((*RequestVoteResponse)(nil), "gorums.RequestVoteResponse")
	proto.RegisterType((*AppendEntriesRequest)(nil), "gorums.AppendEntriesRequest")
	proto.RegisterType((*AppendEntriesResponse)(nil), "gorums.AppendEntriesResponse")
	proto.RegisterType((*RegisterClientRequest)(nil), "gorums.RegisterClientRequest")
	proto.RegisterType((*RegisterClientResponse)(nil), "gorums.RegisterClientResponse")
	proto.RegisterType((*ClientRequestRequest)(nil), "gorums.ClientRequestRequest")
	proto.RegisterType((*ClientRequestResponse)(nil), "gorums.ClientRequestResponse")
	proto.RegisterEnum("gorums.Status", Status_name, Status_value)
}
func (x Status) String() string {
	s, ok := Status_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Entry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Entry)
	if !ok {
		that2, ok := that.(Entry)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Entry")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Entry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Entry but is not nil && this == nil")
	}
	if this.Term != that1.Term {
		return fmt.Errorf("Term this(%v) Not Equal that(%v)", this.Term, that1.Term)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	return nil
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Entry)
	if !ok {
		that2, ok := that.(Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Term != that1.Term {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *RequestVoteRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RequestVoteRequest)
	if !ok {
		that2, ok := that.(RequestVoteRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RequestVoteRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RequestVoteRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RequestVoteRequest but is not nil && this == nil")
	}
	if this.CandidateID != that1.CandidateID {
		return fmt.Errorf("CandidateID this(%v) Not Equal that(%v)", this.CandidateID, that1.CandidateID)
	}
	if this.Term != that1.Term {
		return fmt.Errorf("Term this(%v) Not Equal that(%v)", this.Term, that1.Term)
	}
	if this.LastLogIndex != that1.LastLogIndex {
		return fmt.Errorf("LastLogIndex this(%v) Not Equal that(%v)", this.LastLogIndex, that1.LastLogIndex)
	}
	if this.LastLogTerm != that1.LastLogTerm {
		return fmt.Errorf("LastLogTerm this(%v) Not Equal that(%v)", this.LastLogTerm, that1.LastLogTerm)
	}
	return nil
}
func (this *RequestVoteRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestVoteRequest)
	if !ok {
		that2, ok := that.(RequestVoteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CandidateID != that1.CandidateID {
		return false
	}
	if this.Term != that1.Term {
		return false
	}
	if this.LastLogIndex != that1.LastLogIndex {
		return false
	}
	if this.LastLogTerm != that1.LastLogTerm {
		return false
	}
	return true
}
func (this *RequestVoteResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RequestVoteResponse)
	if !ok {
		that2, ok := that.(RequestVoteResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RequestVoteResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RequestVoteResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RequestVoteResponse but is not nil && this == nil")
	}
	if this.Term != that1.Term {
		return fmt.Errorf("Term this(%v) Not Equal that(%v)", this.Term, that1.Term)
	}
	if this.RequestTerm != that1.RequestTerm {
		return fmt.Errorf("RequestTerm this(%v) Not Equal that(%v)", this.RequestTerm, that1.RequestTerm)
	}
	if this.VoteGranted != that1.VoteGranted {
		return fmt.Errorf("VoteGranted this(%v) Not Equal that(%v)", this.VoteGranted, that1.VoteGranted)
	}
	return nil
}
func (this *RequestVoteResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RequestVoteResponse)
	if !ok {
		that2, ok := that.(RequestVoteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Term != that1.Term {
		return false
	}
	if this.RequestTerm != that1.RequestTerm {
		return false
	}
	if this.VoteGranted != that1.VoteGranted {
		return false
	}
	return true
}
func (this *AppendEntriesRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AppendEntriesRequest)
	if !ok {
		that2, ok := that.(AppendEntriesRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AppendEntriesRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AppendEntriesRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AppendEntriesRequest but is not nil && this == nil")
	}
	if this.LeaderID != that1.LeaderID {
		return fmt.Errorf("LeaderID this(%v) Not Equal that(%v)", this.LeaderID, that1.LeaderID)
	}
	if this.Term != that1.Term {
		return fmt.Errorf("Term this(%v) Not Equal that(%v)", this.Term, that1.Term)
	}
	if this.PrevLogIndex != that1.PrevLogIndex {
		return fmt.Errorf("PrevLogIndex this(%v) Not Equal that(%v)", this.PrevLogIndex, that1.PrevLogIndex)
	}
	if this.PrevLogTerm != that1.PrevLogTerm {
		return fmt.Errorf("PrevLogTerm this(%v) Not Equal that(%v)", this.PrevLogTerm, that1.PrevLogTerm)
	}
	if this.CommitIndex != that1.CommitIndex {
		return fmt.Errorf("CommitIndex this(%v) Not Equal that(%v)", this.CommitIndex, that1.CommitIndex)
	}
	if len(this.Entries) != len(that1.Entries) {
		return fmt.Errorf("Entries this(%v) Not Equal that(%v)", len(this.Entries), len(that1.Entries))
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return fmt.Errorf("Entries this[%v](%v) Not Equal that[%v](%v)", i, this.Entries[i], i, that1.Entries[i])
		}
	}
	return nil
}
func (this *AppendEntriesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AppendEntriesRequest)
	if !ok {
		that2, ok := that.(AppendEntriesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeaderID != that1.LeaderID {
		return false
	}
	if this.Term != that1.Term {
		return false
	}
	if this.PrevLogIndex != that1.PrevLogIndex {
		return false
	}
	if this.PrevLogTerm != that1.PrevLogTerm {
		return false
	}
	if this.CommitIndex != that1.CommitIndex {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	return true
}
func (this *AppendEntriesResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AppendEntriesResponse)
	if !ok {
		that2, ok := that.(AppendEntriesResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AppendEntriesResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AppendEntriesResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AppendEntriesResponse but is not nil && this == nil")
	}
	if this.FollowerID != that1.FollowerID {
		return fmt.Errorf("FollowerID this(%v) Not Equal that(%v)", this.FollowerID, that1.FollowerID)
	}
	if this.Term != that1.Term {
		return fmt.Errorf("Term this(%v) Not Equal that(%v)", this.Term, that1.Term)
	}
	if this.MatchIndex != that1.MatchIndex {
		return fmt.Errorf("MatchIndex this(%v) Not Equal that(%v)", this.MatchIndex, that1.MatchIndex)
	}
	if this.Success != that1.Success {
		return fmt.Errorf("Success this(%v) Not Equal that(%v)", this.Success, that1.Success)
	}
	return nil
}
func (this *AppendEntriesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AppendEntriesResponse)
	if !ok {
		that2, ok := that.(AppendEntriesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FollowerID != that1.FollowerID {
		return false
	}
	if this.Term != that1.Term {
		return false
	}
	if this.MatchIndex != that1.MatchIndex {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *RegisterClientRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegisterClientRequest)
	if !ok {
		that2, ok := that.(RegisterClientRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegisterClientRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegisterClientRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegisterClientRequest but is not nil && this == nil")
	}
	return nil
}
func (this *RegisterClientRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegisterClientRequest)
	if !ok {
		that2, ok := that.(RegisterClientRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *RegisterClientResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RegisterClientResponse)
	if !ok {
		that2, ok := that.(RegisterClientResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RegisterClientResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RegisterClientResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RegisterClientResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.ClientID != that1.ClientID {
		return fmt.Errorf("ClientID this(%v) Not Equal that(%v)", this.ClientID, that1.ClientID)
	}
	if this.LeaderHint != that1.LeaderHint {
		return fmt.Errorf("LeaderHint this(%v) Not Equal that(%v)", this.LeaderHint, that1.LeaderHint)
	}
	return nil
}
func (this *RegisterClientResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegisterClientResponse)
	if !ok {
		that2, ok := that.(RegisterClientResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.LeaderHint != that1.LeaderHint {
		return false
	}
	return true
}
func (this *ClientRequestRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ClientRequestRequest)
	if !ok {
		that2, ok := that.(ClientRequestRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ClientRequestRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ClientRequestRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ClientRequestRequest but is not nil && this == nil")
	}
	if this.ClientID != that1.ClientID {
		return fmt.Errorf("ClientID this(%v) Not Equal that(%v)", this.ClientID, that1.ClientID)
	}
	if this.SequenceNumber != that1.SequenceNumber {
		return fmt.Errorf("SequenceNumber this(%v) Not Equal that(%v)", this.SequenceNumber, that1.SequenceNumber)
	}
	if !bytes.Equal(this.Command, that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	return nil
}
func (this *ClientRequestRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ClientRequestRequest)
	if !ok {
		that2, ok := that.(ClientRequestRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.SequenceNumber != that1.SequenceNumber {
		return false
	}
	if !bytes.Equal(this.Command, that1.Command) {
		return false
	}
	return true
}
func (this *ClientRequestResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ClientRequestResponse)
	if !ok {
		that2, ok := that.(ClientRequestResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ClientRequestResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ClientRequestResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ClientRequestResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if !bytes.Equal(this.Response, that1.Response) {
		return fmt.Errorf("Response this(%v) Not Equal that(%v)", this.Response, that1.Response)
	}
	if this.LeaderHint != that1.LeaderHint {
		return fmt.Errorf("LeaderHint this(%v) Not Equal that(%v)", this.LeaderHint, that1.LeaderHint)
	}
	return nil
}
func (this *ClientRequestResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ClientRequestResponse)
	if !ok {
		that2, ok := that.(ClientRequestResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.Response, that1.Response) {
		return false
	}
	if this.LeaderHint != that1.LeaderHint {
		return false
	}
	return true
}

/* 'gorums' plugin for protoc-gen-go - generated from: config_rpc_tmpl */

// RequestVoteReply encapsulates the reply from a RequestVote RPC invocation.
// It contains the id of each node in the quorum that replied and a single
// reply.
type RequestVoteReply struct {
	NodeIDs []uint32
	Reply   *RequestVoteResponse
}

func (r RequestVoteReply) String() string {
	return fmt.Sprintf("node ids: %v | answer: %v", r.NodeIDs, r.Reply)
}

// RequestVote invokes a RequestVote RPC on configuration c
// and returns the result as a RequestVoteReply.
func (c *Configuration) RequestVote(args *RequestVoteRequest) (*RequestVoteReply, error) {
	return c.mgr.requestVote(c, args)
}

// RequestVoteFuture is a reference to an asynchronous RequestVote RPC invocation.
type RequestVoteFuture struct {
	reply *RequestVoteReply
	err   error
	c     chan struct{}
}

// RequestVoteFuture asynchronously invokes a RequestVote RPC on configuration c and
// returns a RequestVoteFuture which can be used to inspect the RPC reply and error
// when available.
func (c *Configuration) RequestVoteFuture(args *RequestVoteRequest) *RequestVoteFuture {
	f := new(RequestVoteFuture)
	f.c = make(chan struct{}, 1)
	go func() {
		defer close(f.c)
		f.reply, f.err = c.mgr.requestVote(c, args)
	}()
	return f
}

// Get returns the reply and any error associated with the RequestVoteFuture.
// The method blocks until a reply or error is available.
func (f *RequestVoteFuture) Get() (*RequestVoteReply, error) {
	<-f.c
	return f.reply, f.err
}

// Done reports if a reply or error is available for the RequestVoteFuture.
func (f *RequestVoteFuture) Done() bool {
	select {
	case <-f.c:
		return true
	default:
		return false
	}
}

/* 'gorums' plugin for protoc-gen-go - generated from: mgr_rpc_tmpl */

type requestVoteReply struct {
	nid   uint32
	reply *RequestVoteResponse
	err   error
}

func (m *Manager) requestVote(c *Configuration, args *RequestVoteRequest) (*RequestVoteReply, error) {
	replyChan := make(chan requestVoteReply, c.n)
	ctx, cancel := context.WithCancel(context.Background())

	for _, n := range c.nodes {
		go callGRPCRequestVote(ctx, n, args, replyChan)
	}

	var (
		replyValues = make([]*RequestVoteResponse, 0, c.n)
		reply       = &RequestVoteReply{NodeIDs: make([]uint32, 0, c.n)}
		errCount    int
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errCount++
				goto terminationCheck
			}
			replyValues = append(replyValues, r.reply)
			reply.NodeIDs = append(reply.NodeIDs, r.nid)
			if reply.Reply, quorum = c.qspec.RequestVoteQF(replyValues); quorum {
				cancel()
				return reply, nil
			}
		case <-time.After(c.timeout):
			cancel()
			return reply, TimeoutRPCError{c.timeout, errCount, len(replyValues)}
		}

	terminationCheck:
		if errCount+len(replyValues) == c.n {
			cancel()
			return reply, IncompleteRPCError{errCount, len(replyValues)}
		}
	}
}

func callGRPCRequestVote(ctx context.Context, node *Node, args *RequestVoteRequest, replyChan chan<- requestVoteReply) {
	reply := new(RequestVoteResponse)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/gorums.Raft/RequestVote",
		args,
		reply,
		node.conn,
	)
	switch grpc.Code(err) { // nil -> codes.OK
	case codes.OK, codes.Canceled:
		node.setLatency(time.Since(start))
	default:
		node.setLastErr(err)
	}
	replyChan <- requestVoteReply{node.id, reply, err}
}

/* 'gorums' plugin for protoc-gen-go - generated from: node_tmpl */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id   uint32
	self bool
	addr string
	conn *grpc.ClientConn

	RaftClient RaftClient

	sync.Mutex
	lastErr error
	latency time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	var err error
	n.conn, err = grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}

	n.RaftClient = NewRaftClient(n.conn)

	return nil
}

func (n *Node) close() error {
	// TODO: Log error, mainly care about the connection error below.
	// We should log this error, but we currently don't have access to the
	// logger in the manager.

	if err := n.conn.Close(); err != nil {
		return fmt.Errorf("conn close error: %v", err)
	}
	return nil
}

/* 'gorums' plugin for protoc-gen-go - generated from: qspec_tmpl */

// QuorumSpec is the interface that wraps every quorum function.
type QuorumSpec interface {
	// RequestVoteQF is the quorum function for the RequestVote RPC method.
	RequestVoteQF(replies []*RequestVoteResponse) (*RequestVoteResponse, bool)
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id      uint32
	nodes   []*Node
	n       int
	mgr     *Manager
	timeout time.Duration
	qspec   QuorumSpec
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// NewTestConfiguration returns a new configuration with quorum size q and
// node size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		nodes: make([]*Node, n),
	}
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, ReplyCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.ReplyCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited                 time.Duration
	ErrCount, RepliesCount int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

/* mgr.go */

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	sync.RWMutex

	nodes   map[uint32]*Node
	configs map[uint32]*Configuration

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := &Manager{
		nodes:   make(map[uint32]*Node),
		configs: make(map[uint32]*Configuration),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	selfAddrIndex, selfID, err := m.parseSelfOptions(nodeAddrs)
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	idSeen := false
	for i, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err2)
		}
		m.nodes[node.id] = node
		if i == selfAddrIndex {
			node.self = true
			continue
		}
		if node.id == selfID {
			node.self = true
			idSeen = true
		}
	}
	if selfID != 0 && !idSeen {
		return nil, ManagerCreationError(
			fmt.Errorf("WithSelfID provided, but no node with id %d found", selfID),
		)
	}

	err = m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	return m, nil
}

func (m *Manager) parseSelfOptions(addrs []string) (int, uint32, error) {
	if m.opts.selfAddr != "" && m.opts.selfID != 0 {
		return 0, 0, fmt.Errorf("both WithSelfAddr and WithSelfID provided")
	}
	if m.opts.selfID != 0 {
		return -1, m.opts.selfID, nil
	}
	if m.opts.selfAddr == "" {
		return -1, 0, nil
	}

	seen, index := contains(m.opts.selfAddr, addrs)
	if !seen {
		return 0, 0, fmt.Errorf(
			"option WithSelfAddr provided, but address %q was not present in address list",
			m.opts.selfAddr)
	}

	return index, 0, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	id := h.Sum32()

	if _, found := m.nodes[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
	}

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node.
func (m *Manager) NodeIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	ids := make([]uint32, 0, len(m.nodes))
	for id := range m.nodes {
		ids = append(ids, id)
	}
	sort.Sort(idSlice(ids))
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.RLock()
	defer m.RUnlock()
	node, found = m.nodes[id]
	return node, found
}

// Nodes returns a slice of each available node.
func (m *Manager) Nodes(excludeSelf bool) []*Node {
	m.RLock()
	defer m.RUnlock()
	var nodes []*Node
	for _, node := range m.nodes {
		if excludeSelf && node.self {
			continue
		}
		nodes = append(nodes, node)
	}
	OrderedBy(ID).Sort(nodes)
	return nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	sort.Sort(idSlice(ids))
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cnodes []*Node
	for _, nid := range ids {
		node, found := m.nodes[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		if node.self && m.selfSpecified() {
			return nil, IllegalConfigError(
				fmt.Sprintf("self (%d) can't be part of a configuration when a self-option is provided", nid),
			)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted ensure a globally consistent configuration id.
	OrderedBy(ID).Sort(cnodes)

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, timeout)
	for _, node := range cnodes {
		binary.Write(h, binary.LittleEndian, node.id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:      cid,
		nodes:   cnodes,
		n:       len(cnodes),
		mgr:     m,
		qspec:   qspec,
		timeout: timeout,
	}
	m.configs[cid] = c

	return c, nil
}

func (m *Manager) selfSpecified() bool {
	return m.opts.selfAddr != "" || m.opts.selfID != 0
}

type idSlice []uint32

func (p idSlice) Len() int           { return len(p) }
func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p idSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

/* node_func.go */

// ID returns the ID of m.
func (n *Node) ID() uint32 {
	return n.id
}

// Address returns network address of m.
func (n *Node) Address() string {
	return n.addr
}

func (n *Node) String() string {
	n.Lock()
	defer n.Unlock()
	return fmt.Sprintf(
		"node %d | addr: %s | latency: %v",
		n.id, n.addr, n.latency,
	)
}

func (n *Node) setLastErr(err error) {
	n.Lock()
	defer n.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.Lock()
	defer n.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.Lock()
	defer n.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.Lock()
	defer n.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

/* opts.go */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	selfAddr     string
	selfID       uint32
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithSelfAddr returns a ManagerOption which instructs the Manager not to connect
// to the node with network address addr. The address must be present in the
// list of node addresses provided to the Manager.
func WithSelfAddr(addr string) ManagerOption {
	return func(o *managerOptions) {
		o.selfAddr = addr
	}
}

// WithSelfID returns a ManagerOption which instructs the Manager not to
// connect to the node with the given id. The node must be present in the list
// of node addresses provided to the Manager.
func WithSelfID(id uint32) ManagerOption {
	return func(o *managerOptions) {
		o.selfID = id
	}
}

/* util.go */

func contains(addr string, addrs []string) (found bool, index int) {
	for i, a := range addrs {
		if addr == a {
			return true, i
		}
	}
	return false, -1
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Raft service

type RaftClient interface {
	RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error)
	AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error)
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error)
	ClientRequest(ctx context.Context, in *ClientRequestRequest, opts ...grpc.CallOption) (*ClientRequestResponse, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error) {
	out := new(RequestVoteResponse)
	err := grpc.Invoke(ctx, "/gorums.Raft/RequestVote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error) {
	out := new(AppendEntriesResponse)
	err := grpc.Invoke(ctx, "/gorums.Raft/AppendEntries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error) {
	out := new(RegisterClientResponse)
	err := grpc.Invoke(ctx, "/gorums.Raft/RegisterClient", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) ClientRequest(ctx context.Context, in *ClientRequestRequest, opts ...grpc.CallOption) (*ClientRequestResponse, error) {
	out := new(ClientRequestResponse)
	err := grpc.Invoke(ctx, "/gorums.Raft/ClientRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Raft service

type RaftServer interface {
	RequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error)
	AppendEntries(context.Context, *AppendEntriesRequest) (*AppendEntriesResponse, error)
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientResponse, error)
	ClientRequest(context.Context, *ClientRequestRequest) (*ClientRequestResponse, error)
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gorums.Raft/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).RequestVote(ctx, req.(*RequestVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gorums.Raft/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).AppendEntries(ctx, req.(*AppendEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gorums.Raft/RegisterClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_ClientRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).ClientRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gorums.Raft/ClientRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).ClientRequest(ctx, req.(*ClientRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gorums.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestVote",
			Handler:    _Raft_RequestVote_Handler,
		},
		{
			MethodName: "AppendEntries",
			Handler:    _Raft_AppendEntries_Handler,
		},
		{
			MethodName: "RegisterClient",
			Handler:    _Raft_RegisterClient_Handler,
		},
		{
			MethodName: "ClientRequest",
			Handler:    _Raft_ClientRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorRaft,
}

func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.Term))
	}
	if len(m.Data) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintRaft(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *RequestVoteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RequestVoteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CandidateID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.CandidateID))
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.Term))
	}
	if m.LastLogIndex != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaft(data, i, uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintRaft(data, i, uint64(m.LastLogTerm))
	}
	return i, nil
}

func (m *RequestVoteResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RequestVoteResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Term != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.Term))
	}
	if m.RequestTerm != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.RequestTerm))
	}
	if m.VoteGranted {
		data[i] = 0x18
		i++
		if m.VoteGranted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AppendEntriesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AppendEntriesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.LeaderID))
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.Term))
	}
	if m.PrevLogIndex != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaft(data, i, uint64(m.PrevLogIndex))
	}
	if m.PrevLogTerm != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintRaft(data, i, uint64(m.PrevLogTerm))
	}
	if m.CommitIndex != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintRaft(data, i, uint64(m.CommitIndex))
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x32
			i++
			i = encodeVarintRaft(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppendEntriesResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AppendEntriesResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FollowerID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.FollowerID))
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.Term))
	}
	if m.MatchIndex != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaft(data, i, uint64(m.MatchIndex))
	}
	if m.Success {
		data[i] = 0x20
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RegisterClientRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisterClientRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RegisterClientResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisterClientResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.Status))
	}
	if m.ClientID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.ClientID))
	}
	if m.LeaderHint != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaft(data, i, uint64(m.LeaderHint))
	}
	return i, nil
}

func (m *ClientRequestRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClientRequestRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.ClientID))
	}
	if m.SequenceNumber != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaft(data, i, uint64(m.SequenceNumber))
	}
	if len(m.Command) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintRaft(data, i, uint64(len(m.Command)))
		i += copy(data[i:], m.Command)
	}
	return i, nil
}

func (m *ClientRequestResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClientRequestResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaft(data, i, uint64(m.Status))
	}
	if len(m.Response) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintRaft(data, i, uint64(len(m.Response)))
		i += copy(data[i:], m.Response)
	}
	if m.LeaderHint != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaft(data, i, uint64(m.LeaderHint))
	}
	return i, nil
}

func encodeFixed64Raft(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Raft(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRaft(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *RequestVoteRequest) Size() (n int) {
	var l int
	_ = l
	if m.CandidateID != 0 {
		n += 1 + sovRaft(uint64(m.CandidateID))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovRaft(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovRaft(uint64(m.LastLogTerm))
	}
	return n
}

func (m *RequestVoteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.RequestTerm != 0 {
		n += 1 + sovRaft(uint64(m.RequestTerm))
	}
	if m.VoteGranted {
		n += 2
	}
	return n
}

func (m *AppendEntriesRequest) Size() (n int) {
	var l int
	_ = l
	if m.LeaderID != 0 {
		n += 1 + sovRaft(uint64(m.LeaderID))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.PrevLogIndex != 0 {
		n += 1 + sovRaft(uint64(m.PrevLogIndex))
	}
	if m.PrevLogTerm != 0 {
		n += 1 + sovRaft(uint64(m.PrevLogTerm))
	}
	if m.CommitIndex != 0 {
		n += 1 + sovRaft(uint64(m.CommitIndex))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	return n
}

func (m *AppendEntriesResponse) Size() (n int) {
	var l int
	_ = l
	if m.FollowerID != 0 {
		n += 1 + sovRaft(uint64(m.FollowerID))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.MatchIndex != 0 {
		n += 1 + sovRaft(uint64(m.MatchIndex))
	}
	if m.Success {
		n += 2
	}
	return n
}

func (m *RegisterClientRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RegisterClientResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	if m.ClientID != 0 {
		n += 1 + sovRaft(uint64(m.ClientID))
	}
	if m.LeaderHint != 0 {
		n += 1 + sovRaft(uint64(m.LeaderHint))
	}
	return n
}

func (m *ClientRequestRequest) Size() (n int) {
	var l int
	_ = l
	if m.ClientID != 0 {
		n += 1 + sovRaft(uint64(m.ClientID))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRaft(uint64(m.SequenceNumber))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *ClientRequestResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.LeaderHint != 0 {
		n += 1 + sovRaft(uint64(m.LeaderHint))
	}
	return n
}

func sovRaft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Term:` + fmt.Sprintf("%v", this.Term) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestVoteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestVoteRequest{`,
		`CandidateID:` + fmt.Sprintf("%v", this.CandidateID) + `,`,
		`Term:` + fmt.Sprintf("%v", this.Term) + `,`,
		`LastLogIndex:` + fmt.Sprintf("%v", this.LastLogIndex) + `,`,
		`LastLogTerm:` + fmt.Sprintf("%v", this.LastLogTerm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestVoteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestVoteResponse{`,
		`Term:` + fmt.Sprintf("%v", this.Term) + `,`,
		`RequestTerm:` + fmt.Sprintf("%v", this.RequestTerm) + `,`,
		`VoteGranted:` + fmt.Sprintf("%v", this.VoteGranted) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppendEntriesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppendEntriesRequest{`,
		`LeaderID:` + fmt.Sprintf("%v", this.LeaderID) + `,`,
		`Term:` + fmt.Sprintf("%v", this.Term) + `,`,
		`PrevLogIndex:` + fmt.Sprintf("%v", this.PrevLogIndex) + `,`,
		`PrevLogTerm:` + fmt.Sprintf("%v", this.PrevLogTerm) + `,`,
		`CommitIndex:` + fmt.Sprintf("%v", this.CommitIndex) + `,`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "Entry", "Entry", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppendEntriesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppendEntriesResponse{`,
		`FollowerID:` + fmt.Sprintf("%v", this.FollowerID) + `,`,
		`Term:` + fmt.Sprintf("%v", this.Term) + `,`,
		`MatchIndex:` + fmt.Sprintf("%v", this.MatchIndex) + `,`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegisterClientRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegisterClientRequest{`,
		`}`,
	}, "")
	return s
}
func (this *RegisterClientResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegisterClientResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`LeaderHint:` + fmt.Sprintf("%v", this.LeaderHint) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientRequestRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientRequestRequest{`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`SequenceNumber:` + fmt.Sprintf("%v", this.SequenceNumber) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClientRequestResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClientRequestResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Response:` + fmt.Sprintf("%v", this.Response) + `,`,
		`LeaderHint:` + fmt.Sprintf("%v", this.LeaderHint) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringRaft(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidateID", wireType)
			}
			m.CandidateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CandidateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastLogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastLogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTerm", wireType)
			}
			m.RequestTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RequestTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteGranted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VoteGranted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			m.LeaderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogIndex", wireType)
			}
			m.PrevLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PrevLogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogTerm", wireType)
			}
			m.PrevLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PrevLogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIndex", wireType)
			}
			m.CommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowerID", wireType)
			}
			m.FollowerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FollowerID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchIndex", wireType)
			}
			m.MatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MatchIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClientResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClientResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClientResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ClientID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderHint", wireType)
			}
			m.LeaderHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderHint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRequestRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRequestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRequestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ClientID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SequenceNumber |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command[:0], data[iNdEx:postIndex]...)
			if m.Command == nil {
				m.Command = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRequestResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], data[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderHint", wireType)
			}
			m.LeaderHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderHint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaft(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/gorums/raft.proto", fileDescriptorRaft) }

var fileDescriptorRaft = []byte{
	// 682 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xce, 0xa6, 0x69, 0x1a, 0x4d, 0x9a, 0x50, 0x2d, 0x2d, 0x8d, 0x42, 0xbb, 0x8a, 0x2c, 0x54,
	0x2a, 0x84, 0x1a, 0xa9, 0x3c, 0x41, 0x21, 0x51, 0x89, 0x88, 0x9a, 0x6a, 0x53, 0x21, 0x6e, 0x95,
	0x63, 0x6f, 0x53, 0x4b, 0xb1, 0x1d, 0xbc, 0x9b, 0x02, 0x82, 0x43, 0x2f, 0xdc, 0xfb, 0x18, 0xbc,
	0x40, 0x1f, 0x01, 0x89, 0x63, 0x6f, 0x70, 0x6c, 0xcd, 0x85, 0x23, 0x4f, 0x00, 0xc8, 0xeb, 0xb5,
	0xb3, 0x09, 0xae, 0x10, 0xb9, 0x64, 0xe7, 0x9b, 0x9f, 0xfd, 0xbe, 0x99, 0x59, 0xc3, 0xfa, 0x38,
	0xf0, 0x85, 0xdf, 0x1c, 0xfa, 0xc1, 0xc4, 0xe5, 0xcd, 0xc0, 0x3c, 0x11, 0x3b, 0x12, 0xc1, 0xc5,
	0x18, 0xaa, 0x3f, 0x18, 0x3a, 0xe2, 0x74, 0x32, 0xd8, 0xb1, 0x7c, 0xb7, 0x19, 0xb0, 0x91, 0x39,
	0x48, 0x62, 0xe3, 0xbf, 0x38, 0xda, 0x68, 0xc2, 0x62, 0xdb, 0x13, 0xc1, 0x3b, 0x8c, 0xa1, 0x20,
	0x58, 0xe0, 0xd6, 0x50, 0x03, 0x6d, 0x17, 0xa8, 0x3c, 0x47, 0x98, 0x6d, 0x0a, 0xb3, 0x96, 0x6f,
	0xa0, 0xed, 0x65, 0x2a, 0xcf, 0xc6, 0x05, 0x02, 0x4c, 0xd9, 0xeb, 0x09, 0xe3, 0xe2, 0xa5, 0x2f,
	0x98, 0x3a, 0xe2, 0x06, 0x94, 0x2d, 0xd3, 0xb3, 0x1d, 0xdb, 0x14, 0xac, 0xd3, 0x92, 0x55, 0x2a,
	0x54, 0x87, 0xd2, 0x0b, 0xf2, 0xda, 0x05, 0x06, 0x2c, 0x8f, 0x4c, 0x2e, 0xba, 0xfe, 0xb0, 0xe3,
	0xd9, 0xec, 0x6d, 0x6d, 0x41, 0xfa, 0x66, 0xb0, 0xa8, 0xb2, 0xb2, 0x8f, 0xa2, 0xf4, 0x82, 0x0c,
	0xd1, 0x21, 0xc3, 0x85, 0xbb, 0x33, 0x8c, 0xf8, 0xd8, 0xf7, 0x38, 0xcb, 0x54, 0xd4, 0x80, 0x72,
	0x10, 0x87, 0x1e, 0x4d, 0xb9, 0xe8, 0x50, 0x14, 0x71, 0xe6, 0x0b, 0xb6, 0x1f, 0x98, 0x9e, 0x60,
	0xb6, 0x64, 0x54, 0xa2, 0x3a, 0x64, 0x7c, 0x45, 0xb0, 0xba, 0x37, 0x1e, 0x33, 0xcf, 0x8e, 0x3a,
	0xe7, 0x30, 0x9e, 0xf4, 0xa0, 0x0e, 0xa5, 0x11, 0x33, 0x6d, 0x16, 0xa4, 0x0d, 0x48, 0xed, 0xdb,
	0xd4, 0x8f, 0x03, 0x76, 0x36, 0xaf, 0x5e, 0xc7, 0x22, 0x3a, 0xca, 0xd6, 0xd5, 0x6b, 0x90, 0xec,
	0xbc, 0xef, 0xba, 0x8e, 0x88, 0x8b, 0x2c, 0xc6, 0x11, 0x1a, 0x84, 0x1f, 0xc2, 0x12, 0x8b, 0x99,
	0xd6, 0x8a, 0x8d, 0x85, 0xed, 0xf2, 0x6e, 0x65, 0x47, 0xed, 0x80, 0x1c, 0x3d, 0x4d, 0xbc, 0xc6,
	0x47, 0x04, 0x6b, 0x73, 0xca, 0x54, 0x2f, 0x09, 0xc0, 0x89, 0x3f, 0x1a, 0xf9, 0x6f, 0x34, 0x71,
	0x1a, 0x92, 0x29, 0x8f, 0x00, 0xb8, 0xa6, 0xb0, 0x4e, 0x75, 0x71, 0x1a, 0x82, 0x6b, 0xb0, 0xc4,
	0x27, 0x96, 0xc5, 0x38, 0x97, 0xb2, 0x4a, 0x34, 0x31, 0x8d, 0x75, 0x58, 0xa3, 0x6c, 0xe8, 0x70,
	0xc1, 0x82, 0x67, 0x23, 0x87, 0x79, 0x42, 0x75, 0xd8, 0xf8, 0x00, 0xf7, 0xe6, 0x1d, 0x8a, 0xe0,
	0x16, 0x14, 0xb9, 0x30, 0xc5, 0x84, 0x4b, 0x72, 0xd5, 0xdd, 0x6a, 0x22, 0xb1, 0x2f, 0x51, 0xaa,
	0xbc, 0xd1, 0x8c, 0x2c, 0x99, 0xd9, 0x69, 0x49, 0xb2, 0x15, 0x9a, 0xda, 0x11, 0xe1, 0x78, 0x5e,
	0xcf, 0x1d, 0x4f, 0x48, 0xc2, 0x15, 0xaa, 0x21, 0x86, 0x80, 0xd5, 0x19, 0x3a, 0xda, 0xdc, 0xd3,
	0x9a, 0x68, 0xae, 0xe6, 0x16, 0x54, 0x79, 0x14, 0xe6, 0x59, 0xec, 0x60, 0xe2, 0x0e, 0x58, 0xa0,
	0x5a, 0x34, 0x87, 0x46, 0xcd, 0x88, 0x46, 0x66, 0x7a, 0xf1, 0xca, 0x2d, 0xd3, 0xc4, 0x34, 0xde,
	0xc3, 0xda, 0xdc, 0xad, 0xff, 0x2f, 0x39, 0x50, 0x39, 0xea, 0x25, 0xa7, 0xf6, 0xbf, 0x24, 0x3f,
	0xda, 0x87, 0x62, 0x5c, 0x0d, 0x17, 0x21, 0xdf, 0x7b, 0xb1, 0x92, 0xc3, 0xeb, 0x00, 0x07, 0xbd,
	0xa3, 0xe3, 0x6e, 0x7b, 0xaf, 0xd5, 0xa6, 0x2b, 0xbf, 0x93, 0x1f, 0xc2, 0x1b, 0x70, 0xa7, 0xdf,
	0xee, 0xf7, 0x3b, 0xbd, 0x83, 0xe3, 0xf6, 0xab, 0xc3, 0x0e, 0x6d, 0xb7, 0x56, 0x7e, 0xa5, 0xde,
	0xdd, 0xcf, 0x79, 0x28, 0x50, 0xf3, 0x44, 0xe0, 0x43, 0x28, 0x6b, 0x8f, 0x15, 0xd7, 0x13, 0xd2,
	0x7f, 0x7f, 0x53, 0xea, 0xf7, 0x33, 0x7d, 0x31, 0x73, 0xa3, 0x74, 0x7e, 0x59, 0x43, 0x17, 0x97,
	0x35, 0x84, 0xbb, 0x50, 0x99, 0x59, 0x5a, 0xbc, 0x91, 0xe4, 0x65, 0xbd, 0xd2, 0xfa, 0xe6, 0x2d,
	0x5e, 0xd5, 0x91, 0x1e, 0x54, 0x67, 0x57, 0x0c, 0x6f, 0x4e, 0x69, 0x64, 0xec, 0x64, 0x9d, 0xdc,
	0xe6, 0x56, 0x05, 0xbb, 0x50, 0x99, 0x49, 0x98, 0xd2, 0xcb, 0x5a, 0xa6, 0x29, 0xbd, 0xcc, 0xa1,
	0x3f, 0x7d, 0x7c, 0x75, 0x43, 0x72, 0xdf, 0x6e, 0x48, 0xee, 0xfa, 0x86, 0xa0, 0xf3, 0x90, 0xa0,
	0x4f, 0x21, 0x41, 0x5f, 0x42, 0x82, 0xae, 0x42, 0x82, 0xae, 0x43, 0x82, 0x7e, 0x84, 0x24, 0xf7,
	0x33, 0x24, 0xe8, 0xe2, 0x3b, 0xc9, 0x0d, 0x8a, 0xf2, 0x23, 0xff, 0xe4, 0x4f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xa1, 0x07, 0x10, 0x05, 0x2d, 0x06, 0x00, 0x00,
}
